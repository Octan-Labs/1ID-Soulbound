// SPDX-License-Identifier: None
pragma solidity ^0.8.0;

import "../core/SoulBoundMintable.sol";
import "../interfaces/IManagement.sol";
import "./Authentication.sol";
import "./IProfile.sol";

contract Profile is SoulBoundMintable, Authentication, IProfile {
    bytes32 private constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");

    //  Mapping soulboundId -> a list of hash proof
    mapping(uint256 => bytes32[]) private proof;

    constructor(
        IManagement _management,
        string memory _name,
        string memory _symbol,
        string memory _uri
    )
        SoulBoundMintable(_management, _name, _symbol, _uri)
        Authentication("SoulBound Profile", "Version 1")
    {}

    /**
       	@notice Update proof hashes of `_soulboundId`
       	@dev  Caller must have OPERATOR_ROLE
        @param	_soulboundId				Soulbound id
        @param	_proof				        A list of proof hashes

        Note: Hash proof of each profile may be different from one to another
        Example: One might have Twitter, but Instagram whereas another might have both
        Convention: empty data field will be assigned an empty string
        Thus, hash of empty data field is 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
        In addition, calling this function overrides previous setting proof
    */
    function updateProof(
        uint256 _soulboundId,
        bytes32[] calldata _proof
    ) external override hasRole(OPERATOR_ROLE) {
        _requireMinted(_soulboundId);
        require(_proof.length != 0, "Invalid proof");

        proof[_soulboundId] = _proof;

        emit UpdatedProof(_soulboundId, _proof);
    }

    /**
       	@notice Update proof hash of `_soulboundId` at `_index`
       	@dev  Caller must have OPERATOR_ROLE
        @param	_soulboundId				Soulbound id
        @param	_index				        Position index that needs to be updated
        @param	_proof				        A single proof hash

        Note: Proof hashes must be updated before calling this function
    */
    function updateProofAt(
        uint256 _soulboundId,
        uint256 _index,
        bytes32 _proof
    ) external override hasRole(OPERATOR_ROLE) {
        _isValidIndex(_soulboundId, _index);

        bytes32 _oProof = proof[_soulboundId][_index];
        proof[_soulboundId][_index] = _proof;

        emit UpdatedProofAt(_soulboundId, _index, _oProof, _proof);
    }

    /**
       	@notice Query a list of proof hashes of `_soulboundId`
       	@dev  Caller can be ANY
        @param	_soulboundId				Soulbound id

        Note: Must pay attention to size of proof hashes. Example:
        At time n: 10,000 profiles have been updated with proof hashes (Data field length = 7)
        At time n + 1: 5,000 profiles have been updated with proof hashes (Data field length = 10)
        Updating all profiles that are previously set at the time n is too much overhead
        Thus, contract might hold different format of proof hashes
        Convention: should not remove/re-organize order of Data field
    */
    function getProof(
        uint256 _soulboundId
    ) public view override returns (bytes32[] memory) {
        _isSetProof(_soulboundId);
        return proof[_soulboundId];
    }

    /**
       	@notice Query a single proof hash of `_soulboundId` at `_index`
       	@dev  Caller can be ANY
        @param	_soulboundId		    Soulbound id
        @param	_index				    Position index to get data

        Note: Must pay attention to size of proof hashes
    */
    function getProofAt(
        uint256 _soulboundId,
        uint256 _index
    ) public view override returns (bytes32) {
        _isValidIndex(_soulboundId, _index);
        return proof[_soulboundId][_index];
    }

    /**
       	@notice Query proof size of `_soulboundId`
       	@dev  Caller can be ANY
        @param	_soulboundId		    Soulbound id

        Note: `_soulboundId` might have different proof sizes
        However, order of proof hashes are consistent
    */
    function size(uint256 _soulboundId) public view override returns (uint256) {
        return proof[_soulboundId].length;
    }

    /**
       	@notice Verify authentication of `_soulboundId` using signature
       	@dev  Caller can be ANY
        @param	_soulboundId		    Soulbound id
        @param	_random		            Random number generated by authenticator
        @param	_expiry		            Signature expiring time
        @param	_proof		            Three random proof hashes of `_soulboundId` has been picked by Authenticator
        @param	_signature		        Signature that needs to verify authentication
    */
    function verifyBySignature(
        uint256 _soulboundId,
        uint256 _random,
        uint256 _expiry,
        bytes32[3] calldata _proof,
        bytes calldata _signature
    ) external view returns (bool) {
        require(block.timestamp <= _expiry, "Signature expires");

        address _signer = Authentication._getSigner(
            _soulboundId,
            _random,
            _expiry,
            _proof,
            _signature
        );
        return _signer == ownerOf(_soulboundId);
    }

    /**
       	@notice Verify authentication of `_soulboundId` using proof
       	@dev  Caller can be ANY
        @param	_soulboundId		    Soulbound id
        @param	_account		        Account address that needs to check authentication
        @param	_checkingHash		    A hash, generated by Authenticator, of all proof hashes of `_soulboundId`
    */
    function verifyByProof(
        uint256 _soulboundId,
        address _account,
        bytes32 _checkingHash
    ) external view returns (bool) {
        bytes32 _computedHash = keccak256(abi.encode(getProof(_soulboundId)));

        return
            _computedHash == _checkingHash && ownerOf(_soulboundId) == _account;
    }

    /**
       	@notice Verify authentication of `_soulboundId` using proof
       	@dev  Caller can be ANY
        @param	_soulboundId		    Soulbound id
        @param	_account		        Account address that needs to check authentication
        @param	_checkingHash		    A hash, generated by Authenticator, of random order proof hashes of `_soulboundId`
        @param	_indexes		        A list of indexes that will be used to extract proof hashes of `_soulboundId`
    */
    function verifyByProof(
        uint256 _soulboundId,
        address _account,
        bytes32 _checkingHash,
        uint256[] calldata _indexes
    ) external view returns (bool) {
        uint256 _len = _indexes.length;
        require(_len != 0, "Zero length");

        bytes memory _encode;
        for (uint256 i; i < _len; i++)
            _encode = abi.encode(
                _encode,
                getProofAt(_soulboundId, _indexes[i])
            );

        return
            keccak256(_encode) == _checkingHash &&
            ownerOf(_soulboundId) == _account;
    }

    function _isValidIndex(uint256 _soulboundId, uint256 _index) private view {
        uint256 _size = _isSetProof(_soulboundId);
        require(_index <= _size - 1, "Index out of bound");
    }

    function _isSetProof(
        uint256 _soulboundId
    ) private view returns (uint256 _size) {
        _size = size(_soulboundId);
        require(_size != 0, "Soulbound not yet contains any proof");
    }
}
